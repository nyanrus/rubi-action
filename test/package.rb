# typed: true
# frozen_string_literal: true

# This file is a showcase for the project's Ruby-based GHA DSL.
# It programmatically constructs the same workflow found in `package.yml`
# and serves as a proof-of-concept for the DSL's capabilities,
# not as a configuration loader.
# typed: strict
# frozen_string_literal: true

require 'sorbet-runtime'
require_relative 'gha/gha_plugin'
require_relative 'plugin/language_plugin'

module PackageWorkflow
  extend T::Sig

  sig { returns(GHA::Helpers::Workflow) }
  def self.workflow
    api = GHA::API.new_api
    api.load_plugins([GHA::Plugin::LanguagePlugin.create_language_plugin])

    api.workflow '(A) 📦️ Package' do
      on 'workflow_dispatch'
      on 'workflow_call'

      job 'main' do
        runs_on 'ubuntu-latest'

        step 'Checkout ${{ github.repository }}-runtime', uses: 'actions/checkout@v4', with: {
          'repository' => '${{ github.repository }}-runtime',
          'submodules' => 'recursive'
        }
        step 'Checkout ${{ github.repository }}', uses: 'actions/checkout@v4', with: {
          'path' => 'noraneko'
        }
        step 'Setup Node.js', uses: 'actions/setup-node@v4', with: {
          'node-version' => '22'
        }
        step 'Setup Deno', uses: 'denoland/setup-deno@v2', with: {
          'deno-version' => 'v2.x'
        }
        step 'init zx', run: 'deno install -g -A npm:zx'
        step 'Setup Noraneko', run: 'Dir.chdir(ENV["GITHUB_WORKSPACE"]) { Dir.chdir("./noraneko") { system("deno install --allow-scripts") } }'
        step 'Setup 🪛', run: 'sudo apt install msitools -y && ./mach --no-interactive bootstrap --application-choice browser_artifact_mode'
        step 'Write Versions', run: 'Dir.chdir("./noraneko") { system("deno task build --write-version") }'

        step 'Mach configure', run: <<~SH
          if [ "${{inputs.platform}}" == "Windows-x64" ]; then
            cp ./.github/workflows/mozconfigs/win64.mozconfig mozconfig
          elif [ "${{inputs.platform}}" == "Linux-x64" ]; then
            cp ./.github/workflows/mozconfigs/linux64.mozconfig mozconfig
          else
            cp ./.github/workflows/mozconfigs/macosx64-x86_64.mozconfig mozconfig
          fi

          # Copy Noraneko Branding
          cp -r ./noraneko/gecko/branding/* ./browser/branding/

          mkdir noraneko/gecko/config/autogenerated
          echo "$(cat browser/config/version.txt)@$(cat noraneko/gecko/config/version.txt)" >> noraneko/gecko/config/autogenerated/version.txt
          echo "$(cat browser/config/version_display.txt)@$(cat noraneko/gecko/config/version_display.txt)" >> noraneko/gecko/config/autogenerated/version_display.txt
          echo "ac_add_options --with-version-file-path=noraneko/gecko/config/autogenerated" >> mozconfig
          # sed -i 's|ac_add_options --disable-maintenance-service|#ac_add_options --disable-maintenance-service|g' ./mozconfig
          sed -i 's|ac_add_options --disable-updater||g' ./mozconfig
          sed -i 's|ac_add_options --enable-unverified-updates||g' ./mozconfig

          echo "ac_add_options --enable-release" >> mozconfig
          echo "ac_add_options --enable-update-channel=alpha" >> mozconfig
          echo "ac_add_options --disable-tests" >> mozconfig
          echo "ac_add_options --enable-artifact-builds" >> mozconfig
          echo "mk_add_options MOZ_OBJDIR=./obj-artifact-build-output" >> mozconfig

          sed -i 's|MOZ_BRANDING_DIRECTORY=browser/branding/unofficial|MOZ_BRANDING_DIRECTORY=browser/branding/noraneko-unofficial|g' ./browser/confvars.sh
          sed -i 's|ac_add_options --enable-chrome-format=flat||g' ./mozconfig

          if [ "${{inputs.platform}}" == "macOS-x64" ]; then
            # Extract macOS .dmg tools
            mkdir -p ~/tools
            curl -L https://firefox-ci-tc.services.mozilla.com/api/queue/v1/task/ceSQWV1AS76UlhYJ0_PfJQ/artifacts/public/build/dmg.tar.zst -o dmg.tar.zst
            tar -I zstd -xf dmg.tar.zst -C ~/tools
            sudo chmod 777 ~/tools/dmg

            curl -L https://firefox-ci-tc.services.mozilla.com/api/queue/v1/task/N2SwCRLrRw2l-UWP4N7dhQ/artifacts/public/build/hfsplus.tar.zst -o hfsplus.tar.zst
            tar -I zstd -xf hfsplus.tar.zst -C ~/tools
            sudo chmod 777 ~/tools/hfsplus

            # write mozconfig
            echo "DMG_TOOL=$(echo ~/tools/dmg/dmg)" >> mozconfig
            echo "HFS_TOOL=$(echo ~/tools/dmg/hfsplus)" >> mozconfig
            echo "MKFSHFS=$(echo ~/tools/hfsplus/newfs_hfs)" >> mozconfig
          fi

          ./mach configure
          git apply --ignore-space-change --ignore-whitespace .github/patches/packaging/*.patch
        SH

        step 'Possibly retrieve run ID if not provided', run: <<~SH
          if [ -z "${{ inputs.runtime_artifact_workflow_run_id }}" ]; then
            echo "RUNTIME_ARTIFACT_WORKFLOW_RUN_ID=false" >> $GITHUB_ENV
          else
            echo "RUNTIME_ARTIFACT_WORKFLOW_RUN_ID=${{ inputs.runtime_artifact_workflow_run_id }}" >> $GITHUB_ENV
          fi
        SH

        step 'Get Artifact Name', shell: 'zx --verbose {0}', run: <<~JS
          async function addToENV(name,value) {
            await $`echo "${name}=${value}" >> $GITHUB_ENV`
          }
          switch (process.env.BUILD_PLATFORM) {
            case "Windows-x64":
              await addToENV("ARTIFACT_NAME","noraneko-win-amd64-moz-artifact");
              await addToENV("ARTIFACT_FROM_RELEASE_NAME","noraneko-win-amd64-moz-artifact.zip");
              await addToENV("OUTPUT_NAME","win-amd64");
              await $`echo "INSTALLER_PATH=install/sea/*installer.exe" >> $GITHUB_ENV`;
              await addToENV("OUTPUT_INSTALLER_NAME","noraneko-win64-installer.exe");
              break;
            case "Linux-x64":
              await addToENV("ARTIFACT_FROM_RELEASE_NAME","noraneko-linux-amd64-moz-artifact.tar.xz");
              await addToENV("OUTPUT_NAME","linux-amd64");
              await $`echo "INSTALLER_PATH=noraneko*tar.xz" >> $GITHUB_ENV`;
              await addToENV("OUTPUT_INSTALLER_NAME","noraneko-linux-amd64.tar.xz");
              break;
            case "macOS-x64":
              await addToENV("ARTIFACT_NAME","noraneko-mac-universal-moz-artifact-release");
              await addToENV("ARTIFACT_FROM_RELEASE_NAME","noraneko-mac-universal-moz-artifact-release.zip");
              await addToENV("OUTPUT_NAME","mac-universal");
              await $`echo "INSTALLER_PATH=noraneko-*dmg" >> $GITHUB_ENV`;
              await addToENV("OUTPUT_INSTALLER_NAME","noraneko-macOS-universal.dmg");
              break;
          }
        JS

        step 'Download mozilla artifact from Actions', uses: 'actions/download-artifact@v4', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID != 'false' }}", with: {
          'name' => '${{ env.ARTIFACT_NAME }}',
          'run-id' => '${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID }}',
          'github-token' => '${{ github.token }}',
          'repository' => '${{ github.repository }}-runtime',
          'path' => '~/downloads'
        }

        step 'Download Mozilla Artifact from GitHub Releases', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID == 'false' }}", run: <<~SH
          mkdir -p ~/downloads
          curl -L https://github.com/${{ github.repository }}-runtime/releases/latest/download/${{ env.ARTIFACT_FROM_RELEASE_NAME }} -o ~/downloads/${{ env.ARTIFACT_FROM_RELEASE_NAME }}
        SH

        step 'Make Downloaded Artifact to Mozilla Artifact (Actions)', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID != 'false' }}", run: <<~SH
          mkdir -p ~/artifacts
          cd ~/downloads
          if [ "${{inputs.platform}}" == "Windows-x64" ]; then
            zip -r ~/artifacts/noraneko-win-amd64-moz-artifact.zip ./*
          else
            cp -r ~/downloads/* ~/artifacts
          fi
          cd $GITHUB_WORKSPACE
        SH

        step 'Make Download Artifact to Mozilla Artifact (GitHub Releases)', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID == 'false' }}", run: <<~SH
          mkdir -p ~/artifacts
          cd ~/downloads
          if [ "${{inputs.platform}}" == "macOS-x64" ]; then
            unzip noraneko-mac-universal-moz-artifact-release.zip -d ~/artifacts
          else
            cp -r ~/downloads/* ~/artifacts
          fi
          cd $GITHUB_WORKSPACE
        SH

        step 'Build Noraneko', run: <<~SH
          cd ./noraneko
          NODE_ENV='production' deno task build --release-build-before
          cd ..
        SH

        step 'Build', run: <<~SH
          # Backup obj-artifact-build-output before build for rollback
          cp -r obj-artifact-build-output obj-artifact-build-output.bak

          if [ "${{inputs.platform}}" == "Windows-x64" ]; then
            MOZ_ARTIFACT_FILE=~/artifacts/noraneko-win-amd64-moz-artifact.zip ./mach build
          elif [ "${{inputs.platform}}" == "Linux-x64" ]; then
            MOZ_ARTIFACT_FILE=~/artifacts/noraneko-linux-amd64-moz-artifact.tar.xz ./mach build
          elif [ "${{inputs.platform}}" == "macOS-x64" ]; then
            MOZ_ARTIFACT_FILE=~/artifacts/noraneko-macOS-universal-moz-artifact.dmg:~/artifacts/noraneko-macOS.update_framework_artifacts.zip ./mach build
          fi

          # If rollback needed, restore backup
          # cp -r obj-artifact-build-output.bak obj-artifact-build-output
        SH

        step 'Inject Noraneko', run: <<~SH
          # Backup obj-artifact-build-output/dist/bin before inject for rollback
          cp -r obj-artifact-build-output/dist/bin obj-artifact-build-output/dist/bin.bak

          cd ./noraneko
          deno task build --release-build-after
          rsync -aL ../obj-artifact-build-output/dist/bin/ ../obj-artifact-build-output/dist/tmp__bin
          rm -rf ../obj-artifact-build-output/dist/bin
          mv ../obj-artifact-build-output/dist/tmp__bin ../obj-artifact-build-output/dist/bin

          if [ "${{inputs.platform}}" == "macOS-x64" ]; then
            for patch_file in ./scripts/git-patches/patches/*.patch; do
              for resource_dir in ../obj-artifact-build-output/dist/*.app/Contents/Resources; do
                patch --follow-symlinks --dry-run -d "$resource_dir" -p1 < "$patch_file"
                if [ $? -eq 0 ]; then
                  patch --follow-symlinks -d "$resource_dir" -p1 < "$patch_file"
                else
                  echo "Dry-run failed for $patch_file in $resource_dir"
                  exit 1
                fi
              done
            done
          else
            git apply --reject ./scripts/git-patches/patches/*.patch --directory ../obj-artifact-build-output/dist/bin --unsafe-paths --check --apply
          fi

          cd ..

          # If rollback needed, restore backup
          # cp -r obj-artifact-build-output/dist/bin.bak obj-artifact-build-output/dist/bin
        SH

        step 'Package noraneko', run: './mach package'

        step 'Rename and move installer', run: <<~SH
          mkdir -p ~/noraneko-installer
          mv obj-*/dist/$INSTALLER_PATH ~/noraneko-installer/$OUTPUT_INSTALLER_NAME
        SH

        step 'Download artifact of MAR tools (Actions)', uses: 'actions/download-artifact@v4', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID != 'false' }}", with: {
          'pattern' => '*dist-host',
          'run-id' => '${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID }}',
          'github-token' => '${{ github.token }}',
          'repository' => '${{ github.repository }}-runtime',
          'path' => 'obj-artifact-build-output/dist/host',
          'merge-multiple' => 'true'
        }

        step 'Download artifact of MAR tools (GitHub Releases)', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID == 'false' }}", run: <<~SH
          curl -L https://github.com/${{ github.repository }}-runtime/releases/latest/download/${{ inputs.platform }}-dist-host.zip -o ~/downloads/${{ inputs.platform }}-dist-host.zip
          unzip ~/downloads/${{ inputs.platform }}-dist-host.zip -d ./obj-artifact-build-output/dist/host
        SH

        step 'Download artifact of binary for getting build information (Actions)', uses: 'actions/download-artifact@v4', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID != 'false' }}", with: {
          'pattern' => '*application-ini',
          'run-id' => '${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID }}',
          'github-token' => '${{ github.token }}',
          'repository' => '${{ github.repository }}-runtime',
          'path' => '~/noraneko-dev',
          'merge-multiple' => 'true'
        }

        step 'Download artifact of binary for getting build information (GiHub Releases)', if_: "${{ env.RUNTIME_ARTIFACT_WORKFLOW_RUN_ID == 'false' }}", run: <<~SH
          curl -L https://github.com/${{ github.repository }}-runtime/releases/latest/download/${{ inputs.platform }}-application-ini.zip -o ~/downloads/${{ inputs.platform }}-application-ini.zip
          unzip ~/downloads/${{ inputs.platform }}-application-ini.zip -d ~/noraneko-dev
        SH

        step 'Create MAR package', run: <<~'RUBY'
          require 'fileutils'
          require 'json'
          require 'digest'

          # Find obj_dir
          obj_dir = Dir.glob('./obj-*').first
          raise 'Could not find obj-* directory' unless obj_dir

          # Define paths
          home_dir = Dir.home
          mar_dir = File.join(home_dir, 'noraneko-mar')
          publish_dir = File.join(home_dir, 'noraneko-publish')
          dev_dir = File.join(home_dir, 'noraneko-dev')
          application_ini_path = File.join(dev_dir, 'nora-application.ini')
          mar_tool_path = File.join(obj_dir, 'dist', 'host', 'bin', 'mar')
          output_name = ENV.fetch('OUTPUT_NAME')
          mar_file_name = "noraneko-#{output_name}-full.mar"
          mar_file_path = File.join(mar_dir, mar_file_name)

          # Create directories
          FileUtils.mkdir_p(mar_dir)
          FileUtils.mkdir_p(publish_dir)

          # Make mar tool executable
          FileUtils.chmod('+x', mar_tool_path)

          # Extract info from application.ini
          application_ini = File.read(application_ini_path)
          version = application_ini[/^Version=(.*)$/, 1]&.strip
          build_id = application_ini[/^BuildID=(.*)$/, 1]&.strip
          raise 'Could not extract Version from application.ini' unless version
          raise 'Could not extract BuildID from application.ini' unless build_id

          # Create precomplete file
          FileUtils.touch(File.join(obj_dir, 'dist', 'noraneko', 'precomplete'))

          # Create MAR package
          update_script = './tools/update-packaging/make_full_update.sh'
          noraneko_dist_dir = File.join(obj_dir, 'dist', 'noraneko')
          mar_env = {
            'MAR' => mar_tool_path,
            'MOZ_PRODUCT_VERSION' => version,
            'MAR_CHANNEL_ID' => 'alpha'
          }
          system(mar_env, "#{update_script} \\"#{mar_file_path}\\" \\"#{noraneko_dist_dir}\\"")

          # Noraneko version and buildid
          noraneko_version = File.read('noraneko/gecko/config/version.txt').strip
          noraneko_buildid = File.read('noraneko/_dist/buildid2').strip

          # Get MAR file info
          mar_shasum = Digest::SHA512.file(mar_file_path).hexdigest
          mar_size = File.size(mar_file_path).to_s

          # Create meta.json
          meta_data = {
            version: version,
            noraneko_version: noraneko_version,
            noraneko_buildid: noraneko_buildid,
            mar_size: mar_size,
            mar_shasum: mar_shasum,
            buildid: build_id
          }
          File.write(File.join(publish_dir, 'meta.json'), JSON.pretty_generate(meta_data))

          # Copy MAR to publish dir
          FileUtils.cp(mar_file_path, publish_dir)
        RUBY

        step 'Publish dist 🎁', uses: 'actions/upload-artifact@v4', with: {
          'name' => 'noraneko-${{ env.OUTPUT_NAME }}-installer',
          'path' => '~/noraneko-installer/*',
          'compression-level' => '9'
        }

        step 'Publish MAR 🎁', uses: 'actions/upload-artifact@v4', with: {
          'name' => 'noraneko-${{ env.OUTPUT_NAME }}-mar-full',
          'path' => '~/noraneko-publish/*'
        }
      end # job 'main'
    end # api.workflow
  end # def self.workflow
end # module PackageWorkflow
